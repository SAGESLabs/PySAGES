# SPDX-License-Identifier: MIT
# See LICENSE.md and CONTRIBUTORS.md at https://github.com/SSAGESLabs/PySAGES

"""
Collective variable related to native contacts.

Q describes the fraction of the native contacts
for folding of proteins or nucleic acids
"""
from jax import numpy as np

from pysages.colvars.core import CollectiveVariable, multicomponent


def remap_indices(contacts, sorted_unique_indices):
    # create the mapping from old indices to new indices
    old_indices = np.array(sorted_unique_indices)
    new_indices = np.arange(len(sorted_unique_indices))
    index_mapping = np.zeros(old_indices.max() + 1, dtype=new_indices.dtype)
    index_mapping = index_mapping.at[old_indices].set(new_indices)

    contacts = np.array(contacts)
    remapped_contacts = index_mapping[contacts]

    return remapped_contacts


@multicomponent
class NativeContactFraction(CollectiveVariable):
    """
    Calculate the native contact fraction Q.

    Parameters
    ------------
    indices: list[int]
        List of the indices of the atoms of interests.
        indices should be equal to np.unique(contact_pairs)
    contact_pairs: list[tuple(int)]
        List of pairs of indices of atoms (list of contacts) to be considered.
        The overall shape should be (n_contacts, 2).
        These pairs are usually generated by a cutoff radius.
        For example, in a system with 5 atoms, if in the reference structure,
        only 2-3, 2-4 and 1-5 are in contact with each other,
        we should pass in [(2, 3), (2, 4), (1, 5)]
    reference: list[tuple(float)]
        Reference coordinates for the selected atoms.
    gamma: float
        Smoothing parameter. Default is 50 nm^-1.
    lambda_d: float
        Scaling factor for the distances.
    """

    def __init__(self, indices, contact_pairs, references, gamma=50, lambda_d=1.5):
        super().__init__(indices)
        indices = np.sort(np.asarray(indices))
        contact_pairs = np.asarray(contact_pairs)
        assert all(
            indices == np.unique(contact_pairs)
        ), "contact pairs should contain and only contain index from indices"
        self.contact_pairs = remap_indices(contact_pairs, indices)

        self.references = np.asarray(references)
        self.gamma = gamma
        self.lambda_d = lambda_d

    @property
    def function(self):
        return lambda r: native_contact_fraction(
            r, self.contact_pairs, self.references, self.gamma, self.lambda_d
        )


def native_contact_fraction(r, contact_pairs, references, gamma, lambda_d):
    r"""
    Calculate the native contact fraction Q.

    Parameters
    ----------
    r: (n_atoms, 3) array
        Current positions of the atoms.
    contact_pairs: (n_contacts, 2) array
        pairs of indices of atoms that are in contact.
    references: (n_atoms, 3) array
        Reference contact distances.
    gamma: float
        Smoothing parameter.
    lambda_d: float
        Scaling factor for the distances.

    Returns
    -------
    Q: float
        Native contact fraction.

    Mathematical details can be found in
    [Best, Mittal, JPCB, 2010](https://pubs.acs.org/doi/10.1021/jp102575b)
    :math:`Q=\frac{1}{N_\mathrm{contacts}}\sum_{(i, j)} \frac{1}{1+\exp(\gamma(r_{ij}-r_{ij}^0))}`

    """
    # Calculate pairwise distances
    distances = np.linalg.norm(r[:, None, :] - r[None, :, :], axis=-1)
    reference_distances = np.linalg.norm(references[:, None, :] - references[None, :, :], axis=-1)

    # Calculate Q
    diff = distances - lambda_d * reference_distances
    Q_matrix = 1 / (1 + np.exp(gamma * diff))
    Q_contribution = Q_matrix[contact_pairs[:, 0], contact_pairs[:, 1]]

    N_contacts = contact_pairs.shape[0]

    return np.sum(Q_contribution) / N_contacts
